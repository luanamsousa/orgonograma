<!DOCTYPE html>
<html lang="pt-br">
<head>
<meta charset="UTF-8" />
<title>Organograma Funcional – Exportação</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />

<style>
  :root{
    --blue-900:#0b2b45;
    --blue-700:#0b5ed7;
    --blue-500:#0dcaf0;
    --line:#9db8d3;
    --box-bg:#eef6ff;
    --box-border:#7fb0ff;
    --chip-bg:#e6fbff;
    --chip-border:#86dff2;
  }

  body{
    margin:0;
    padding:18px 18px 28px;
    font-family: Arial, sans-serif;
    background:#fff;
    color: var(--blue-900);
  }

  h1{
    text-align:center;
    margin:0 0 6px 0;
    color: var(--blue-900);
    font-size: 22px;
  }

  .sub{
    text-align:center;
    margin:0 0 16px 0;
    font-weight:bold;
    color:#456;
    font-size: 12px;
  }

  .acoes{
    text-align:center;
    margin: 10px 0 16px;
  }

  button{
    background: var(--blue-700);
    color:#fff;
    border:none;
    padding:10px 16px;
    border-radius:10px;
    font-weight:bold;
    cursor:pointer;
    box-shadow: 0 8px 18px rgba(11,94,215,.18);
  }
  button:hover{ background:#094bb0; }

  /* ✅ CENTRALIZA o organograma */
  .wrap{
    display:flex;
    justify-content:center;
    align-items:flex-start;
    width:100%;
    padding: 8px 6px 20px;
  }

  .tree{
    display:inline-block;
    padding: 0;
    margin: 0 auto;
  }

  .tree ul{
    padding-top: 18px;
    position: relative;
    padding-left: 0;
    margin:0;
    display:flex;
    justify-content:center;
    gap: 18px;
  }

  .tree li{
    list-style-type:none;
    text-align:center;
    position: relative;
    padding: 18px 10px 0 10px;
    margin:0;
  }

  .tree li::before,
  .tree li::after{
    content:'';
    position:absolute;
    top:0;
    right:50%;
    border-top: 2px solid var(--line);
    width:50%;
    height:18px;
  }
  .tree li::after{
    right:auto;
    left:50%;
    border-left: 2px solid var(--line);
  }

  .tree li:only-child::after,
  .tree li:only-child::before{ display:none; }

  .tree li:first-child::before{ border:none; }
  .tree li:last-child::after{ border:none; }

  .tree li .node::before{
    content:'';
    position:absolute;
    top:-18px;
    left:50%;
    transform:translateX(-50%);
    border-left:2px solid var(--line);
    width:0;
    height:18px;
  }

  .tree > ul > li > .node::before{ display:none; }
  .tree > ul > li::before,
  .tree > ul > li::after{ display:none; }

  .node{
    position: relative;
    background: var(--box-bg);
    border: 2px solid var(--box-border);
    border-radius: 10px;
    min-width: 240px;
    max-width: 320px;
    padding: 10px 12px 12px;
    box-shadow: 0 8px 20px rgba(0,0,0,.08);
    display: inline-block;
  }

  .node-title{
    font-weight: 900;
    color: var(--blue-700);
    font-size: 12px;
    letter-spacing: .2px;
    margin-bottom: 6px;
    text-transform: uppercase;
  }

  .node-name{
    font-weight: 900;
    color: var(--blue-900);
    font-size: 14px;
    margin-bottom: 8px;
    line-height: 1.15;
  }

  .chips{
    display:flex;
    flex-wrap:wrap;
    gap: 6px;
    justify-content:center;
  }

  .chip{
    border:1px solid var(--chip-border);
    background: var(--chip-bg);
    border-radius: 999px;
    padding: 6px 10px;
    font-weight: 800;
    font-size: 11px;
    color:#053b4c;
    white-space: nowrap;
  }

  .empty{
    font-style: italic;
    color:#667;
    font-weight: bold;
    font-size: 11px;
    padding: 4px 0;
  }

  .msg{
    text-align:center;
    font-weight:900;
    color:#334;
    padding: 18px 10px;
  }

  @media print{
    .acoes{ display:none !important; }
    body{ padding: 0; }
    .wrap{ padding: 0; }

    /* A4 horizontal */
    @page{ size: A4 landscape; margin: 12mm; }

    /* leve redução pra caber melhor */
    .tree{ transform: scale(.92); transform-origin: top center; }
    .node{ box-shadow:none !important; }
  }
</style>
</head>

<body>

<h1>Organograma Funcional</h1>
<p class="sub" id="subtitulo">Carregando…</p>

<div class="acoes">
  <button onclick="window.print()">Exportar para PDF</button>
</div>

<div class="wrap">
  <div id="tree" class="tree"></div>
  <div id="msg" class="msg" style="display:none;"></div>
</div>

<script>
  // ✅ TROQUE pela sua URL /exec atual
  const BASE =
    "https://script.google.com/macros/s/AKfycbyigyFcP5TxvuawbFkbdc7H2PyRhITazUHLMn2vcaWyea5wL6b5RXnFlWQC1F-bTnBVbg/exec";

  const params = new URLSearchParams(window.location.search);
  const FILTRO_RAW = params.get("posto") || "TODOS";

  function norm(t){
    return String(t || "")
      .trim()
      .toUpperCase()
      .normalize("NFD")
      .replace(/[\u0300-\u036f]/g, "");
  }

  const FILTRO = norm(FILTRO_RAW);

  document.getElementById("subtitulo").textContent =
    (FILTRO === "TODOS")
      ? "Exportação (Todos os postos)"
      : `Exportação (Filtro: ${FILTRO_RAW})`;

  const DATA_URL = BASE + "?mode=data&callback=cb&_=" + Date.now();

  function cb(payload){
    if(!payload || payload.error){
      document.getElementById("subtitulo").textContent = "Erro ao carregar dados.";
      showMsg("Não foi possível carregar os dados.");
      return;
    }
    renderTree(payload.hierarchy || [], payload.people || []);
  }

  function showMsg(text){
    const msg = document.getElementById("msg");
    msg.textContent = text;
    msg.style.display = "block";
  }

  function renderTree(hierarchy, people){
    // 1) aplica filtro nas pessoas
    let peopleFiltered = people.slice();
    if (FILTRO !== "TODOS") {
      peopleFiltered = peopleFiltered.filter(p => norm(p.posto) === FILTRO);
    }

    // Se tiver filtro e não existir ninguém, avisa
    if (FILTRO !== "TODOS" && peopleFiltered.length === 0) {
      document.getElementById("tree").innerHTML = "";
      showMsg("Nenhuma pessoa encontrada para o filtro selecionado.");
      return;
    }

    // 2) mapa sup (func -> sup) e filhos (sup -> funcs)
    const supByFunc = new Map();
    const childrenBySup = new Map();

    hierarchy.forEach(h => {
      const f = String(h.func || "").trim();
      const s = String(h.sup || "").trim();
      if(!f) return;
      supByFunc.set(f, s || "");
      if(!childrenBySup.has(s || "")) childrenBySup.set(s || []);
      childrenBySup.get(s || "").push(f);
    });

    // 3) Pessoas agrupadas por função
    const peopleByFunc = new Map();
    peopleFiltered.forEach(p => {
      const key = String(p.func || "").trim();
      if(!key) return;
      if(!peopleByFunc.has(key)) peopleByFunc.set(key, []);
      peopleByFunc.get(key).push(p);
    });

    // 4) Se filtro != TODOS: manter apenas funções que têm pessoas + seus ancestrais
    let allowedFuncs = null;

    if (FILTRO !== "TODOS") {
      allowedFuncs = new Set();

      // funcs com pessoas
      for (const func of peopleByFunc.keys()) {
        let cur = func;
        while (cur) {
          if (allowedFuncs.has(cur)) break;
          allowedFuncs.add(cur);
          cur = (supByFunc.get(cur) || "").trim();
        }
      }
    }

    // 5) Monta árvore (nodes) respeitando allowedFuncs
    const nodeMap = new Map();
    const getNode = (name) => {
      const k = String(name || "").trim();
      if(!k) return null;
      if (allowedFuncs && !allowedFuncs.has(k)) return null;
      if(!nodeMap.has(k)) nodeMap.set(k, { name:k, children:[] });
      return nodeMap.get(k);
    };

    hierarchy.forEach(h => {
      const func = String(h.func || "").trim();
      const sup  = String(h.sup  || "").trim();
      if(!func) return;

      const node = getNode(func);
      if(!node) return;

      if(sup){
        const parent = getNode(sup);
        if(parent) parent.children.push(node);
      }
    });

    // 6) Descobre raízes (só dentro do allowedFuncs)
    const childrenSet = new Set();
    nodeMap.forEach(n => n.children.forEach(c => childrenSet.add(c.name)));

    let roots = [];
    nodeMap.forEach(n => {
      if(!childrenSet.has(n.name)) roots.push(n);
    });

    // fallback: se hierarquia não ajudou, cria nó por função existente
    if(roots.length === 0){
      const funcs = [...new Set(peopleFiltered.map(p => String(p.func||"").trim()).filter(Boolean))];
      roots = funcs.map(f => getNode(f)).filter(Boolean);
    }

    if(!roots.length){
      document.getElementById("tree").innerHTML = "";
      showMsg("Não há dados para exportar.");
      return;
    }

    // 7) Render
    const tree = document.getElementById("tree");
    tree.innerHTML = "";
    document.getElementById("msg").style.display = "none";

    const topUl = document.createElement("ul");
    roots.forEach(r => topUl.appendChild(renderNode(r, peopleByFunc)));
    tree.appendChild(topUl);
  }

  function renderNode(node, peopleByFunc){
    const li = document.createElement("li");

    const box = document.createElement("div");
    box.className = "node";

    const t1 = document.createElement("div");
    t1.className = "node-title";
    t1.textContent = "FUNÇÃO";

    const t2 = document.createElement("div");
    t2.className = "node-name";
    t2.textContent = node.name;

    box.appendChild(t1);
    box.appendChild(t2);

    const pessoas = peopleByFunc.get(node.name) || [];
    if(pessoas.length === 0){
      const empty = document.createElement("div");
      empty.className = "empty";
      empty.textContent = "Sem pessoas cadastradas";
      box.appendChild(empty);
    } else {
      const chips = document.createElement("div");
      chips.className = "chips";
      pessoas.forEach(p => {
        const chip = document.createElement("div");
        chip.className = "chip";
        chip.textContent = `${p.posto} - ${p.nome}`;
        chips.appendChild(chip);
      });
      box.appendChild(chips);
    }

    li.appendChild(box);

    if(node.children && node.children.length){
      const ul = document.createElement("ul");
      node.children.forEach(child => ul.appendChild(renderNode(child, peopleByFunc)));
      li.appendChild(ul);
    }

    return li;
  }

  const s = document.createElement("script");
  s.src = DATA_URL;
  s.onerror = () => {
    document.getElementById("subtitulo").textContent = "Erro ao carregar script de dados.";
    showMsg("Erro ao carregar o Web App (Apps Script).");
  };
  document.head.appendChild(s);
</script>

</body>
</html>
